<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Session Viewer</title>
    <link rel="stylesheet" href="/static/style.css?v=17">
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        // Force cache bust
        console.log('Page loaded at:', new Date().toISOString())
        console.log('Checking libraries...')
        window.addEventListener('load', function () {
            console.log('marked:', typeof marked)
            console.log('DOMPurify:', typeof DOMPurify)
            console.log('hljs:', typeof hljs)
        });
    </script>
</head>

<body>
    <div class="app-container">
        <!-- Left Sidebar: Projects -->
        <aside class="sidebar left-sidebar">
            <div class="sidebar-header">
                <h1>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    Claude Sessions
                </h1>
                <div class="sort-controls">
                    <button class="sort-btn active" onclick="sortProjects('created')" title="Sort by Creation Date">
                        <span>üìÖ Created</span>
                    </button>
                    <button class="sort-btn" onclick="sortProjects('updated')" title="Sort by Last Update">
                        <span>üîÑ Updated</span>
                    </button>
                </div>
                <div class="session-info">
                    {{ len .Projects }} Projects
                </div>
            </div>
            <div class="search-box" style="padding: 0 1rem 0.5rem;">
                <input type="text" id="project-search" class="search-input" placeholder="Search projects...">
            </div>
            <div class="projects-list" id="projects-list">
                {{ range .Projects }}
                {{ $latest := 0 }}
                {{ if gt (len .Sessions) 0 }}
                {{ $latest = (index .Sessions 0).StartTime.Unix }}
                {{ end }}

                {{ $earliest := $latest }}
                {{ range .Sessions }}
                {{ $earliest = .StartTime.Unix }}
                {{ end }}

                <div class="project-item"
                    onclick="selectProject('{{ .EncodedPath }}', '{{ .DecodedPath | getProjectName }}', this)"
                    data-created="{{ $earliest }}" data-updated="{{ $latest }}">
                    <div class="project-header">
                        <span class="project-icon">üìÇ</span>
                        <div class="project-name">{{ .DecodedPath | getProjectName }}</div>
                    </div>
                </div>
                {{ end }}
            </div>
        </aside>

        <!-- Middle Sidebar: Sessions -->
        <aside class="sidebar middle-sidebar">
            <div class="sidebar-header">
                <h2>üìù Sessions</h2>
                <div class="session-info" id="project-info">
                    <small>„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</small>
                </div>
            </div>
            <div class="sessions-list" id="sessions-list">
                <div class="empty-state">
                    <svg width="80" height="80" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path
                            d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z">
                        </path>
                    </svg>
                    <p>„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíÈÅ∏Êäû„Åô„Çã„Å®<br>„Çª„ÉÉ„Ç∑„Éß„É≥‰∏ÄË¶ß„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô</p>
                </div>
            </div>
        </aside>

        <!-- Main Content: Chat View -->
        <main class="main-content">
            <div class="content-header">
                <h2>üí¨ Chat History</h2>
                <div class="prompt-info" id="session-info">
                    <small>„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</small>
                </div>
            </div>
            <div class="response-container chat-container" id="chat-container">
                <div class="empty-state">
                    <svg width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor"
                        stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <path d="M8 14s1.5 2 4 2 4-2 4-2"></path>
                        <line x1="9" y1="9" x2="9.01" y2="9"></line>
                        <line x1="15" y1="9" x2="15.01" y2="9"></line>
                    </svg>
                    <p>„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åô„Çã„Å®<br>„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô</p>
                </div>
            </div>
        </main>
    </div>

    <script>
        let currentEncodedPath = null
        let currentSessionId = null

        // Load projects on page load
        document.addEventListener('DOMContentLoaded', () => {
            setupSearch()
        })

        // Select a project and load its sessions
        async function selectProject(encodedPath, projectName, element) {
            // Remove previous active states
            document.querySelectorAll('.project-item').forEach(el => el.classList.remove('active'))
            element.classList.add('active')

            // Update project info
            document.getElementById('project-info').innerHTML = `<small>${projectName}</small>`

            // Load sessions
            await loadSessions(encodedPath)

            // Clear chat
            document.getElementById('chat-container').innerHTML = `
                <div class="empty-state">
                    <svg width="100" height="100" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                    </svg>
                    <p>„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åô„Çã„Å®<br>„ÉÅ„É£„ÉÉ„ÉàÂ±•Ê≠¥„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô</p>
                </div>
            `
            document.getElementById('session-info').innerHTML = '<small>„Çª„ÉÉ„Ç∑„Éß„É≥„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</small>'
        }

        // Load sessions for a project
        async function loadSessions(encodedPath) {
            const container = document.getElementById('sessions-list')
            container.innerHTML = '<div class="loading">Loading sessions...</div>'

            try {
                const response = await fetch(`/api/projects/${encodedPath}/sessions`)
                const sessions = await response.json()

                if (sessions.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>„Çª„ÉÉ„Ç∑„Éß„É≥„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p></div>'
                    return
                }

                container.innerHTML = sessions.map(session => `
                    <div class="session-item" onclick="selectSession('${encodedPath}', '${session.ID}', this)">
                        <div class="session-date">${formatDate(session.StartTime)}</div>
                        <div class="session-preview">${escapeHtml(session.FirstMessage.substring(0, 50))}${session.FirstMessage.length > 50 ? '...' : ''}</div>
                        <div class="session-meta">
                            <span>üí¨ ${session.MessageCount}</span>
                        </div>
                    </div>
                `).join('')
            } catch (error) {
                container.innerHTML = '<div class="error">„Çª„ÉÉ„Ç∑„Éß„É≥„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</div>'
                console.error('Failed to load sessions:', error)
            }
        }

        // Select a session and load full chat history
        async function selectSession(encodedPath, sessionId, element) {
            // Remove previous active states
            document.querySelectorAll('.session-item').forEach(el => el.classList.remove('active'))
            element.classList.add('active')

            currentEncodedPath = encodedPath
            currentSessionId = sessionId

            // Update session info
            document.getElementById('session-info').innerHTML = `<small>Session: ${sessionId}</small>`

            // Load full chat history
            await loadFullChat(encodedPath, sessionId)
        }

        // Load full chat history
        async function loadFullChat(encodedPath, sessionId) {
            const container = document.getElementById('chat-container')
            container.innerHTML = '<div class="loading">Loading conversation...</div>'

            try {
                const response = await fetch(`/api/projects/${encodedPath}/sessions/${sessionId}/full`)
                const messages = await response.json()

                if (messages.length === 0) {
                    container.innerHTML = '<div class="empty-state"><p>‰ºöË©±„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</p></div>'
                    return
                }

                container.innerHTML = messages.map(msg => renderMessageBubble(msg)).join('')

                // Process code blocks
                processCodeBlocks()

            } catch (error) {
                container.innerHTML = '<div class="error">‰ºöË©±„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</div>'
                console.error('Failed to load chat:', error)
            }
        }

        // Render a single message bubble
        function renderMessageBubble(msg) {
            const isUser = msg.role === 'user'
            const roleName = isUser ? 'User' : 'Claude'
            const badgeClass = isUser ? 'user-message' : 'assistant-message' // Using existing classes for coloring
            const uuid = 'msg-' + Math.random().toString(36).substr(2, 9)

            const contentHtml = renderMarkdown(msg.content)

            return `
                <div class="message-block ${badgeClass}">
                    <div class="message-header">
                        <span class="role-badge">${isUser ? 'üë§' : 'ü§ñ'} ${roleName}</span>
                        <span class="timestamp">${formatTime(msg.timestamp)}</span>
                    </div>
                    <div class="collapsible-container collapsed-content" id="${uuid}">
                        <div class="message-content">
                            ${contentHtml}
                        </div>
                        <div class="collapse-overlay">
                            <button class="show-more-btn" onclick="toggleContent('${uuid}')">Show More</button>
                        </div>
                    </div>
                </div>
            `
        }

        // Toggle content expansion
        function toggleContent(id) {
            const container = document.getElementById(id)
            if (container.classList.contains('collapsed-content')) {
                container.classList.remove('collapsed-content')
                container.classList.add('expanded-content')
                container.querySelector('.show-more-btn').textContent = 'Show Less'
            } else {
                container.classList.remove('expanded-content')
                container.classList.add('collapsed-content')
                container.querySelector('.show-more-btn').textContent = 'Show More'
            }
        }

        // Render markdown content safely
        function renderMarkdown(content) {
            console.log('renderMarkdown called with content length:', content.length)
            console.log('marked available:', typeof marked !== 'undefined')
            console.log('DOMPurify available:', typeof DOMPurify !== 'undefined')
            console.log('hljs available:', typeof hljs !== 'undefined')

            if (typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
                console.warn('marked or DOMPurify not available, falling back to pre')
                return `<pre class="plain-text">${escapeHtml(content)}</pre>`
            }

            try {
                // Configure marked for better rendering
                marked.setOptions({
                    breaks: true,
                    gfm: true,
                    headerIds: true,
                    mangle: false,
                    highlight: function (code, lang) {
                        if (typeof hljs !== 'undefined') {
                            if (lang && hljs.getLanguage(lang)) {
                                try {
                                    return hljs.highlight(code, { language: lang }).value
                                } catch (err) {
                                    console.warn('Highlight error:', err)
                                }
                            }
                            return hljs.highlightAuto(code).value
                        }
                        return code
                    }
                })

                const rawHtml = marked(content)
                console.log('Markdown rendered, HTML length:', rawHtml.length)
                const sanitized = DOMPurify.sanitize(rawHtml)
                console.log('HTML sanitized, final length:', sanitized.length)
                return sanitized
            } catch (e) {
                console.error('Markdown rendering error:', e)
                return `<pre class="plain-text">${escapeHtml(content)}</pre>`
            }
        }


        // Extract filename from text
        function extractFilename(text) {
            if (!text) return null

            // Common patterns
            const patterns = [
                /File Path: `?([^`\n]+)`?/i,
                /File: `?([^`\n]+)`?/i,
                /Updated `?([^`\n]+)`?/i,
                /Created `?([^`\n]+)`?/i,
                /^`([^`\n]+\.[a-z0-9]+)`:?/i, // Starts with `filename.ext`:
                /`([^`\n]+\.[a-z0-9]+)`/i // Contains `filename.ext`
            ]

            for (const pattern of patterns) {
                const match = text.match(pattern)
                if (match && match[1]) {
                    // Cleanup path, get basename if it's a long path
                    let path = match[1].trim()
                    if (path.includes('/')) {
                        path = path.split('/').pop()
                    }
                    return path
                }
            }
            return null
        }

        // Post-process code blocks to add Mac-style window headers
        function processCodeBlocks() {
            const pres = document.querySelectorAll('.message-content pre:not(.plain-text)')

            pres.forEach(pre => {
                // Skip if already processed
                if (pre.parentNode.classList.contains('code-window')) return

                // Try to find filename from previous context
                let filename = 'Code'
                let previousNode = pre.previousSibling

                // Look back a few nodes for filename info
                let attempts = 3
                while (previousNode && attempts > 0) {
                    if (previousNode.nodeType === Node.TEXT_NODE || previousNode.nodeType === Node.ELEMENT_NODE) {
                        const text = previousNode.textContent
                        const extracted = extractFilename(text)
                        if (extracted) {
                            filename = extracted
                            break
                        }
                    }
                    previousNode = previousNode.previousSibling
                    attempts--
                }

                // If extracts "Code" or similar generic terms, check language class
                if (filename === 'Code') {
                    const code = pre.querySelector('code')
                    if (code) {
                        const langClass = Array.from(code.classList).find(c => c.startsWith('language-'))
                        if (langClass) {
                            filename = langClass.replace('language-', '').toUpperCase()
                        }
                    }
                }

                // Create wrapper
                const wrapper = document.createElement('div')
                wrapper.className = 'code-window'

                // Create header
                const header = document.createElement('div')
                header.className = 'code-header'

                header.innerHTML = `
                    <div class="window-controls">
                        <span class="window-red"></span>
                        <span class="window-yellow"></span>
                        <span class="window-green"></span>
                    </div>
                    <div class="code-filename">${escapeHtml(filename)}</div>
                    <div class="copy-button">
                        <span>Copy</span>
                    </div>
                `

                // Setup Copy Button
                const copyBtn = header.querySelector('.copy-button')
                copyBtn.addEventListener('click', async () => {
                    const code = pre.querySelector('code')
                    const text = code ? code.textContent : pre.textContent

                    try {
                        await navigator.clipboard.writeText(text)
                        copyBtn.classList.add('copied')
                        copyBtn.innerHTML = 'Check ‚úì'

                        setTimeout(() => {
                            copyBtn.classList.remove('copied')
                            copyBtn.innerHTML = '<span>Copy</span>'
                        }, 2000)
                    } catch (err) {
                        console.error('Failed to copy', err)
                    }
                })

                // Insert wrapper
                pre.parentNode.insertBefore(wrapper, pre)
                wrapper.appendChild(header)
                wrapper.appendChild(pre)
            })
        }

        // Load response for a prompt
        async function loadResponse(encodedPath, sessionId, promptIndex) {
            const container = document.getElementById('response-container')
            container.innerHTML = '<div class="loading">Loading response...</div>'

            try {
                const response = await fetch(`/api/projects/${encodedPath}/sessions/${sessionId}/prompts/${promptIndex}`)
                const data = await response.json()

                const promptHtml = data.prompt ? `
                    <div class="message-block prompt-block">
                        <div class="message-header">
                            <span class="role-badge user">üë§ User Prompt</span>
                            <span class="timestamp">${formatTime(data.prompt.timestamp)}</span>
                        </div>
                        <div class="message-content">
                            ${renderMarkdown(data.prompt.content)}
                        </div>
                    </div>
                ` : ''

                const responseHtml = data.response ? `
                    <div class="message-block response-block">
                        <div class="message-header">
                            <span class="role-badge assistant">ü§ñ Assistant Response</span>
                            <span class="timestamp">${formatTime(data.response.timestamp)}</span>
                        </div>
                        <div class="message-content">
                            ${renderMarkdown(data.response.content)}
                        </div>
                    </div>
                ` : '<div class="no-response">ÂõûÁ≠î„Åå„ÅÇ„Çä„Åæ„Åõ„Çì</div>'

                container.innerHTML = promptHtml + responseHtml

                // Process code blocks for Mac-style windows
                processCodeBlocks()

            } catch (error) {
                container.innerHTML = '<div class="error">ÂõûÁ≠î„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü</div>'
                console.error('Failed to load response:', error)
            }
        }

        // Add copy functionality to code blocks
        function addCopyButtons() {
            document.querySelectorAll('.message-content pre').forEach((pre) => {
                pre.style.cursor = 'pointer'
                pre.addEventListener('click', async (e) => {
                    const code = pre.querySelector('code')
                    const text = code ? code.textContent : pre.textContent

                    try {
                        await navigator.clipboard.writeText(text)

                        // Visual feedback
                        const originalBefore = window.getComputedStyle(pre, '::before').content
                        pre.setAttribute('data-copied', 'true')
                        pre.style.setProperty('--copy-text', '"Copied!"')

                        setTimeout(() => {
                            pre.removeAttribute('data-copied')
                            pre.style.removeProperty('--copy-text')
                        }, 2000)
                    } catch (err) {
                        console.error('Failed to copy:', err)
                    }
                })
            })
        }

        // Sort projects
        function sortProjects(criteria) {
            const container = document.querySelector('.projects-list')
            const projects = Array.from(document.querySelectorAll('.project-item'))

            // Update buttons
            document.querySelectorAll('.sort-btn').forEach(btn => {
                btn.classList.remove('active')
                if (btn.onclick.toString().includes(criteria)) {
                    btn.classList.add('active')
                }
            })

            projects.sort((a, b) => {
                const aVal = parseInt(a.dataset[criteria] || 0)
                const bVal = parseInt(b.dataset[criteria] || 0)

                // Descending order (newest/latest first) for Updated
                // Descending order (newest first) for Created? Usually "Creation Date" sort means Newest First?
                // The user asked: "First sort by creation date, then allows sort by updated".
                // Usually "Sort by Created" implies Newest Created First or Oldest?
                // Standard file explorers: Name (ASC), Date Modified (DESC), Date Created (DESC).
                // Let's assume Newest First (Desc) for both dates is the most useful default.

                return bVal - aVal
            })

            // Re-append
            projects.forEach(p => container.appendChild(p))
        }

        // Initialize sort (Default: Created)
        window.addEventListener('load', () => {
            sortProjects('created')
        })

        // Setup search functionality
        function setupSearch() {
            const searchInput = document.getElementById('project-search')
            searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase()
                const projects = document.querySelectorAll('.project-item')

                projects.forEach(project => {
                    const projectName = project.querySelector('.project-name').textContent.toLowerCase()
                    if (projectName.includes(query)) {
                        project.style.display = 'block'
                    } else {
                        project.style.display = 'none'
                    }
                })
            })
        }

        // Utility functions
        function getProjectName(path) {
            const parts = path.split('/')
            return parts[parts.length - 1] || path
        }

        function formatDate(timestamp) {
            const date = new Date(timestamp)
            return date.toLocaleString('ja-JP', {
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            })
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp)
            return date.toLocaleString('ja-JP', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            })
        }

        function formatRelativeTime(timestamp) {
            const now = new Date()
            const date = new Date(timestamp)
            const diffMs = now - date
            const diffMinutes = Math.floor(diffMs / 60000)
            const diffHours = Math.floor(diffMs / 3600000)
            const diffDays = Math.floor(diffMs / 86400000)

            if (diffMinutes < 1) {
                return '„Åü„Å£„Åü‰ªä'
            } else if (diffMinutes < 60) {
                return `${diffMinutes}ÂàÜÂâç`
            } else if (diffHours < 24) {
                return `${diffHours}ÊôÇÈñìÂâç`
            } else if (diffDays === 1) {
                return 'Êò®Êó•'
            } else if (diffDays < 7) {
                return `${diffDays}Êó•Ââç`
            } else if (diffDays < 30) {
                const weeks = Math.floor(diffDays / 7)
                return `${weeks}ÈÄ±ÈñìÂâç`
            } else if (diffDays < 365) {
                const months = Math.floor(diffDays / 30)
                return `${months}„É∂ÊúàÂâç`
            } else {
                const years = Math.floor(diffDays / 365)
                return `${years}Âπ¥Ââç`
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div')
            div.textContent = text
            return div.innerHTML
        }
    </script>
</body>

</html>